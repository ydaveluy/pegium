

#pragma once

#include <any>
#include <concepts>
#include <cstddef>
#include <functional>
#include <limits>
#include <map>
#include <memory>
#include <pegium/IParser.hpp>
#include <pegium/grammar.hpp>
#include <pegium/syntax-tree.hpp>
#include <string>
#include <string_view>

namespace pegium {

class Parser : public IParser {
public:
  /*ParseResult parse(const std::string &input) const override { return {}; }
  ParseResult parse(const std::string &name, std::string_view text) const {
    auto c = createContext();
    auto result = _rules.at(name)->parse(text, c);

    // result.value = getValue(*result.root_node);
    return result;
  }*/
  ~Parser() noexcept override = default;


protected:
template <typename... H, typename... I>
auto makeContext(std::tuple<H &...> &&hiddens = std::tie(),
       std::tuple<I &...> &&ignored = std::tie()) const{
        return std::make_unique<
        grammar::Context<std::tuple<H &...>, std::tuple<I &...>>>(
        std::forward<std::tuple<H &...>>(hiddens),
        std::forward<std::tuple<I &...>>(ignored));
       }
  /*template<typename T>
  using TerminalRule = pegium::TerminalRule<T>;*/

private:
  // grammar::Context createContext() const {

  /*std::vector<const grammar::TerminalRule *> hiddens;
  for (auto &[_, def] : _rules) {
    if (const auto *terminal =
            dynamic_cast<grammar::TerminalRule *>(def.get())) {
      if (terminal->hidden())
        hiddens.push_back(terminal);
    }
  }*/

  // return grammar::Context{/*std::move(hiddens)*/};
  //}

  // std::map<std::string, std::shared_ptr<grammar::IRule>, std::less<>> _rules;
};

} // namespace pegium